module Defining where

-- Applicative is a Monoidal Functor


-- class Functor f => Applicative f where
--     pure :: a -> f a
--     (<*>) :: f (a -> b) -> f a -> f b -- tie fighter or ap (short for apply)

-- The pure function embeds something into functorial structure

-- Prelude> :t fmap
-- fmap :: Functor f => (a -> b) -> f a -> f b
-- Prelude> :t (<*>)
-- (<*>) :: Applicative f => f (a -> b) -> f a -> f b


-- fmap f x = pure f <*> x
-- Prelude> fmap (+1) [1,2,3]
-- [2,3,4]
-- Prelude> pure (+1) <*> [1..3]
-- [2,3,4]

-- Prelude> pure 1 :: [Int]
-- [1]
-- Prelude> pure 1 :: Maybe Int
-- Just 1
-- Prelude> pure 1 :: Either a Int
-- Right 1
-- Prelude> pure 1 :: ([a], Int)
-- ([],1)


-- ($)   ::   (a -> b) ->   a ->   b
-- (<$>) ::   (a -> b) -> f a -> f b
-- (<*>) :: f (a -> b) -> f a -> f b


-- With Applicative, we have a Monoid for our structure and function
-- application for our values!

-- mappend :: f             f      f
-- $       ::   (a -> b)      a      b
-- (<*>)   :: f (a -> b) -> f a -> f b


-- -- List
-- [(*2), (*3)] <*> [4, 5]

-- =
-- [2 * 4, 2 * 5, 3 * 4, 3 * 5]

-- -- reduced
-- [8,10,12,15]



-- So what was (a -> b) enriched with in f (a -> b) -> f a -> f
-- b? In this case, “list-ness”. Although the actual application of each
-- (a -> b) to a value of type 𝑎 is quite ordinary, we now have a list of
-- functions rather than a single function as would be the case if it was
-- just the List Functor.

-- Prelude> Just (*2) <*> Just 2
-- Just 4
-- Prelude> Just (*2) <*> Nothing
-- Nothing
-- Prelude> Nothing <*> Just 2
-- Nothing
-- Prelude> Nothing <*> Nothing
-- Nothing

-------------------------------------------------------
-- Prelude> :info (,)
-- data (,) a b = (,) a b -- Defined in ‘GHC.Tuple’
-- ...
-- instance Monoid a => Applicative ((,) a) -- Defined in ‘GHC.Base’
-- ...
-- instance (Monoid a, Monoid b) => Monoid (a, b)
--
-- For the Applicative instance of two-tuple, we don't need a monoid for the b, because b is generated by applying the function to a.
-- BUT WE NEED A MONOID FOR THE FIRST VALUE IN THE TUPLE because we have 2 values and need to produce one value of the same type

-- Prelude> ("Woo", (+1)) <*> (" Jooooo", -10)
-- ("Woo Jooooo",-9)

-- Prelude> import Data.Monoid
-- Prelude Data.Monoid> ((Sum 2), (+1)) <*> ((Sum 0), 0)
-- (Sum {getSum = 2},1)
-- Prelude Data.Monoid> ((Product 3), (*5)) <*> ((Product 7),2)
-- (Product {getProduct = 21},10)
-- Prelude Data.Monoid> ((All True), (+1)) <*> ((All False), 0)
-- (All {getAll = False},1)

-- instance Monoid a => Applicative ((,) a) where
--     pure x = (mempty, x)
--     (u, f) <*> (v, x) =
--          (u `mappend` v, f x)

----------------------------------------------------------------

-- instance Monoid a => Monoid (Maybe a) where
--     mempty = Nothing
--     mappend m         Nothing    = m
--     mappend Nothing   m          = m
--     mappend (Just a)  (Just a')  = Just (mappend a a')


-- instance Applicative Maybe where
--     pure = Just
--     Nothing <*> _       = Nothing
--     _       <*> Nothing = Nothing
--     Just f  <*> Just a  = Just (f a)


-- The monoidal bit may not be what you recognize as the
-- canonical mappend of that type, because some types can have multiple
-- monoids.

--------------------------------------------------------